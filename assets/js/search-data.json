{
  
    
        "post0": {
            "title": "The fastest way to build data apps using Python",
            "content": "Streamlit’s open-source app framework is the easiest way for data scientists and machine learning engineers to create beautiful, performant apps in only a few hours! All in pure Python. All for free. . Streamlit combines three simple ideas: . Embrace Python scripting | Adding a widget is stright forward. No need to write a backend, define routes, handle HTTP requests, etc | Deploy instantly | . . A minimal framework for powerful apps | image source:Streamlit.io . Video . . Reference . Streamlit webpage[ Link] . Documentation [ Link ] . GitHub[ Link ] .",
            "url": "https://itskarthicklakshmanan.github.io/kalanai/jupyter/2020/06/18/Streamlit_tool.html",
            "relUrl": "/jupyter/2020/06/18/Streamlit_tool.html",
            "date": " • Jun 18, 2020"
        }
        
    
  
    
        ,"post1": {
            "title": "3D Photography",
            "content": "An interesting approach for converting a single RGB-D input image into a 3D photo, i.e., a multi-layer representation for novel view synthesis that contains hallucinated color and depth structures in regions occluded in the original view. Using a Layered Depth Image with explicit pixel connectivity as underlying representation, a learning-based inpainting model is presented that iteratively synthesizes new local color-and-depth content into the occluded region in a spatial context-aware manner. . . Video . . . Citation . Meng-Li Shih, Shih-Yang Su, Johannes Kopf, and Jia-Bin Huang. &quot;3D Photography using Context-aware Layered Depth Inpainting&quot;, in IEEE Conference on Computer Vision and Pattern Recognition (CVPR), 2020 . Home page[ Link] . Supplimentary website [ Link ] GitHub[ Link ] .",
            "url": "https://itskarthicklakshmanan.github.io/kalanai/computer%20vision/image%20analysis/2020/06/18/3d_photographs.html",
            "relUrl": "/computer%20vision/image%20analysis/2020/06/18/3d_photographs.html",
            "date": " • Jun 18, 2020"
        }
        
    
  
    
        ,"post2": {
            "title": "Deep Face generator",
            "content": "A team of researchers from the Chinese Academy of Sciences and the City University of Hong Kong presented a novel deep learning framework for synthesizing realistic face images from rough and/or incomplete freehand sketches. . The system takes a local-to-global approach by first decomposing a sketched face into components, refining its individual components by projecting them to component manifolds defined by the existing component samples in the feature spaces, mapping the refined feature vectors to the feature maps for spatial combination, and finally translating the combined feature maps to realistic images. This approach naturally supports local editing and makes the involved network easy to train from a training dataset of not very large scale. . Deep learning uses sketch-to-image translation usually takes ‘hard’ constraints or fixed sketches then try to reconstruct the missing texture/pattern or shading information between line strokes, in this new approach that implicitly learn a space of plausible face sketches from real face sketch images and find the point in this space that best approximates the input sketch. . The system consists of: . CE (Component Embedding), | FM (Feature Mapping), and | IS (Image Synthesis). | . . APPLICATIONS . Face Morphing . This framework follows a simple but effective morphing approach by: . 1) decomposing a pair of source and target face sketches in the training dataset into five components; . 2) encoding the component sketches as feature vectors in the corresponding feature spaces; . 3) performing linear interpolation between the source and target feature vectors for the corresponding components; . 4) finally feeding the interpolated feature vectors to the FM and IS module to get intermediate face images. . . Face Copy-Paste . Several synthesized new faces by re-combining eyes, nose, mouth and the remainder region from four source sketches. The image synthesis sub-network is able to resolve the inconsistencies between face components from different sources in terms of both lighting and shape. . . Video . . Reference . DeepFaceDrawing: Deep Generation of Face Images from Sketches [ Article pdf] .",
            "url": "https://itskarthicklakshmanan.github.io/kalanai/2020/06/15/deepface_generator.html",
            "relUrl": "/2020/06/15/deepface_generator.html",
            "date": " • Jun 15, 2020"
        }
        
    
  
    
        ,"post3": {
            "title": "Fastpages Notebook Blog Post",
            "content": "About . This notebook is a demonstration of some of capabilities of fastpages with notebooks. . With fastpages you can save your jupyter notebooks into the _notebooks folder at the root of your repository, and they will be automatically be converted to Jekyll compliant blog posts! . Front Matter . The first cell in your Jupyter Notebook or markdown blog post contains front matter. Front matter is metadata that can turn on/off options in your Notebook. It is formatted like this: . # &quot;My Title&quot; &gt; &quot;Awesome summary&quot; - toc:true- branch: master- badges: true- comments: true - author: Hamel Husain &amp; Jeremy Howard - categories: [fastpages, jupyter] . Setting toc: true will automatically generate a table of contents | Setting badges: true will automatically include GitHub and Google Colab links to your notebook. | Setting comments: true will enable commenting on your blog post, powered by utterances. | . The title and description need to be enclosed in double quotes only if they include special characters such as a colon. More details and options for front matter can be viewed on the front matter section of the README. . Markdown Shortcuts . A #hide comment at the top of any code cell will hide both the input and output of that cell in your blog post. . A #hide_input comment at the top of any code cell will only hide the input of that cell. . The comment #hide_input was used to hide the code that produced this. . put a #collapse-hide flag at the top of any cell if you want to hide that cell by default, but give the reader the option to show it: . #collapse-hide import pandas as pd import altair as alt . . put a #collapse-show flag at the top of any cell if you want to show that cell by default, but give the reader the option to hide it: . #collapse-show cars = &#39;https://vega.github.io/vega-datasets/data/cars.json&#39; movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; sp500 = &#39;https://vega.github.io/vega-datasets/data/sp500.csv&#39; stocks = &#39;https://vega.github.io/vega-datasets/data/stocks.csv&#39; flights = &#39;https://vega.github.io/vega-datasets/data/flights-5k.json&#39; . . Interactive Charts With Altair . Charts made with Altair remain interactive. Example charts taken from this repo, specifically this notebook. . Example 1: DropDown . # single-value selection over [Major_Genre, MPAA_Rating] pairs # use specific hard-wired values as the initial selected values selection = alt.selection_single( name=&#39;Select&#39;, fields=[&#39;Major_Genre&#39;, &#39;MPAA_Rating&#39;], init={&#39;Major_Genre&#39;: &#39;Drama&#39;, &#39;MPAA_Rating&#39;: &#39;R&#39;}, bind={&#39;Major_Genre&#39;: alt.binding_select(options=genres), &#39;MPAA_Rating&#39;: alt.binding_radio(options=mpaa)} ) # scatter plot, modify opacity based on selection alt.Chart(movies).mark_circle().add_selection( selection ).encode( x=&#39;Rotten_Tomatoes_Rating:Q&#39;, y=&#39;IMDB_Rating:Q&#39;, tooltip=&#39;Title:N&#39;, opacity=alt.condition(selection, alt.value(0.75), alt.value(0.05)) ) . Example 2: Tooltips . alt.Chart(movies).mark_circle().add_selection( alt.selection_interval(bind=&#39;scales&#39;, encodings=[&#39;x&#39;]) ).encode( x=&#39;Rotten_Tomatoes_Rating:Q&#39;, y=alt.Y(&#39;IMDB_Rating:Q&#39;, axis=alt.Axis(minExtent=30)), # use min extent to stabilize axis title placement tooltip=[&#39;Title:N&#39;, &#39;Release_Date:N&#39;, &#39;IMDB_Rating:Q&#39;, &#39;Rotten_Tomatoes_Rating:Q&#39;] ).properties( width=600, height=400 ) . Example 3: More Tooltips . # select a point for which to provide details-on-demand label = alt.selection_single( encodings=[&#39;x&#39;], # limit selection to x-axis value on=&#39;mouseover&#39;, # select on mouseover events nearest=True, # select data point nearest the cursor empty=&#39;none&#39; # empty selection includes no data points ) # define our base line chart of stock prices base = alt.Chart().mark_line().encode( alt.X(&#39;date:T&#39;), alt.Y(&#39;price:Q&#39;, scale=alt.Scale(type=&#39;log&#39;)), alt.Color(&#39;symbol:N&#39;) ) alt.layer( base, # base line chart # add a rule mark to serve as a guide line alt.Chart().mark_rule(color=&#39;#aaa&#39;).encode( x=&#39;date:T&#39; ).transform_filter(label), # add circle marks for selected time points, hide unselected points base.mark_circle().encode( opacity=alt.condition(label, alt.value(1), alt.value(0)) ).add_selection(label), # add white stroked text to provide a legible background for labels base.mark_text(align=&#39;left&#39;, dx=5, dy=-5, stroke=&#39;white&#39;, strokeWidth=2).encode( text=&#39;price:Q&#39; ).transform_filter(label), # add text labels for stock prices base.mark_text(align=&#39;left&#39;, dx=5, dy=-5).encode( text=&#39;price:Q&#39; ).transform_filter(label), data=stocks ).properties( width=700, height=400 ) . Data Tables . You can display tables per the usual way in your blog: . movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; df = pd.read_json(movies) # display table with pandas df[[&#39;Title&#39;, &#39;Worldwide_Gross&#39;, &#39;Production_Budget&#39;, &#39;Distributor&#39;, &#39;MPAA_Rating&#39;, &#39;IMDB_Rating&#39;, &#39;Rotten_Tomatoes_Rating&#39;]].head() . Title Worldwide_Gross Production_Budget Distributor MPAA_Rating IMDB_Rating Rotten_Tomatoes_Rating . 0 The Land Girls | 146083.0 | 8000000.0 | Gramercy | R | 6.1 | NaN | . 1 First Love, Last Rites | 10876.0 | 300000.0 | Strand | R | 6.9 | NaN | . 2 I Married a Strange Person | 203134.0 | 250000.0 | Lionsgate | None | 6.8 | NaN | . 3 Let&#39;s Talk About Sex | 373615.0 | 300000.0 | Fine Line | None | NaN | 13.0 | . 4 Slam | 1087521.0 | 1000000.0 | Trimark | R | 3.4 | 62.0 | . Images . Local Images . You can reference local images and they will be copied and rendered on your blog automatically. You can include these with the following markdown syntax: . ![](my_icons/fastai_logo.png) . . Remote Images . Remote images can be included with the following markdown syntax: . ![](https://image.flaticon.com/icons/svg/36/36686.svg) . . Animated Gifs . Animated Gifs work, too! . ![](https://upload.wikimedia.org/wikipedia/commons/7/71/ChessPawnSpecialMoves.gif) . . Captions . You can include captions with markdown images like this: . ![](https://www.fast.ai/images/fastai_paper/show_batch.png &quot;Credit: https://www.fast.ai/2020/02/13/fastai-A-Layered-API-for-Deep-Learning/&quot;) . . Other Elements . GitHub Flavored Emojis . Typing I give this post two :+1:! will render this: . I give this post two :+1:! . Tweetcards . Typing &gt; twitter: https://twitter.com/jakevdp/status/1204765621767901185?s=20 will render this: Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 . Youtube Videos . Typing &gt; youtube: https://youtu.be/XfoYk_Z5AkI will render this: . Boxes / Callouts . Typing &gt; Warning: There will be no second warning! will render this: . Warning: There will be no second warning! . Typing &gt; Important: Pay attention! It&#39;s important. will render this: . Important: Pay attention! It&#8217;s important. . Typing &gt; Tip: This is my tip. will render this: . Tip: This is my tip. . Typing &gt; Note: Take note of this. will render this: . Note: Take note of this. . Typing &gt; Note: A doc link to [an example website: fast.ai](https://www.fast.ai/) should also work fine. will render in the docs: . Note: A doc link to an example website: fast.ai should also work fine. . Footnotes . You can have footnotes in notebooks, however the syntax is different compared to markdown documents. This guide provides more detail about this syntax, which looks like this: . For example, here is a footnote {% fn 1 %}. And another {% fn 2 %} {{ &#39;This is the footnote.&#39; | fndetail: 1 }} {{ &#39;This is the other footnote. You can even have a [link](www.github.com)!&#39; | fndetail: 2 }} . For example, here is a footnote 1. . And another 2 . 1. This is the footnote.↩ . 2. This is the other footnote. You can even have a link!↩ .",
            "url": "https://itskarthicklakshmanan.github.io/kalanai/jupyter/2020/02/20/test.html",
            "relUrl": "/jupyter/2020/02/20/test.html",
            "date": " • Feb 20, 2020"
        }
        
    
  
    
        ,"post4": {
            "title": "Python for ML",
            "content": ". Python Collections . Collection Types: . 1) List is a collection which is ordered and changeable. Allows duplicate members . 2) Tuple is a collection which is ordered and unchangeable. Allows duplicate members . 3) Set is a collection which is unordered and unindexed. No duplicate members . 4) Dictionary is a collection which is unordered, changeable and indexed. No duplicate members. . 1) List . list = [&quot;apple&quot;, &quot;grapes&quot;, &quot;banana&quot;] print(list) . [&#39;apple&#39;, &#39;grapes&#39;, &#39;banana&#39;] . print(list[1]) #access the list items by referring to the index number . grapes . print(list[-1]) #Negative indexing means beginning from the end, -1 refers to the last item . banana . list2 = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;, &quot;orange&quot;, &quot;kiwi&quot;, &quot;melon&quot;, &quot;mango&quot;] print(list2[:4]) #By leaving out the start value, the range will start at the first item . [&#39;apple&#39;, &#39;banana&#39;, &#39;cherry&#39;, &#39;orange&#39;] . print(list2[2:]) . [&#39;cherry&#39;, &#39;orange&#39;, &#39;kiwi&#39;, &#39;melon&#39;, &#39;mango&#39;] . print(list2[-4:-1]) #range . [&#39;orange&#39;, &#39;kiwi&#39;, &#39;melon&#39;] . list3 = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;] list3[1] = &quot;D&quot; #change the value of a specific item, by refering to the index number print(list3) . [&#39;A&#39;, &#39;D&#39;, &#39;C&#39;] . # For loop list4 = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;] for x in list4: print(x) . apple banana cherry . #To determine if a specified item is present in a list if &quot;apple&quot; in list4: print(&quot;Yes&quot;) . Yes . #To determine how many items a list has print(len(list4)) . 3 . . List Methods: . append() : Adds an element at the end of the list | clear() : Removes all the elements from the list | copy() : Returns a copy of the list | count() : Returns the number of elements with the specified value | extend() : Add the elements of a list (or any iterable), to the end of the current list | index() : Returns the index of the first element with the specified value | insert() : Adds an element at the specified position | pop() : Removes the element at the specified position | remove() : Removes the item with the specified value | reverse() : Reverses the order of the list | sort() : Sorts the list | . #append() method to append an item list4.append(&quot;orange&quot;) print(list4) . [&#39;apple&#39;, &#39;banana&#39;, &#39;cherry&#39;, &#39;orange&#39;] . #Insert an item as the second position list4.insert(1, &quot;orange&quot;) print(list4) . [&#39;apple&#39;, &#39;orange&#39;, &#39;banana&#39;, &#39;cherry&#39;, &#39;orange&#39;] . #The remove() method removes the specified item list4.remove(&quot;banana&quot;) print(list4) . [&#39;apple&#39;, &#39;orange&#39;, &#39;cherry&#39;, &#39;orange&#39;] . #pop() method removes the specified index #and the last item if index is not specified list4.pop() print(list4) . [&#39;apple&#39;, &#39;orange&#39;, &#39;cherry&#39;] . #The del keyword removes the specified index del list4[0] print(list4) . [&#39;orange&#39;, &#39;cherry&#39;] . #The del keyword can also delete the list completely del list4 ptint(list4) . NameError Traceback (most recent call last) &lt;ipython-input-27-fcb70c6c4d66&gt; in &lt;module&gt; 1 #The del keyword can also delete the list completely -&gt; 2 del list4 3 ptint(list4) NameError: name &#39;list4&#39; is not defined . #The clear() method empties the list list5 = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;] list5.clear() print(list5) . [] . #the copy() method to make a copy of a list list5 = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;] mylist = list5.copy() print(mylist) . [&#39;apple&#39;, &#39;banana&#39;, &#39;cherry&#39;] . #Join Two Lists list1 = [&quot;a&quot;, &quot;b&quot; , &quot;c&quot;] list2 = [1, 2, 3] list3 = list1 + list2 print(list3) . [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, 1, 2, 3] . #Append list2 into list1 list1 = [&quot;a&quot;, &quot;b&quot; , &quot;c&quot;] list2 = [1, 2, 3] for x in list2: list1.append(x) print(list1) . [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, 1, 2, 3] . #the extend() method to add list2 at the end of list1 list1 = [&quot;a&quot;, &quot;b&quot; , &quot;c&quot;] list2 = [1, 2, 3] list1.extend(list2) print(list1) . [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, 1, 2, 3] . 2) Tuple . A tuple is a collection which is ordered and unchangeable. . tuple1 = (&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;) print(tuple1) . (&#39;apple&#39;, &#39;banana&#39;, &#39;cherry&#39;) . #access tuple item print(tuple1[1]) . banana . #Negative indexing means beginning from the end, -1 refers to the last item print(tuple1[-1]) . cherry . #Range : Return the third, fourth, and fifth item tuple2 = (&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;, &quot;orange&quot;, &quot;kiwi&quot;, &quot;melon&quot;, &quot;mango&quot;) print(tuple2[2:5]) . (&#39;cherry&#39;, &#39;orange&#39;, &#39;kiwi&#39;) . #Specify negative indexes if you want to start the search from the end of the tuple print(tuple2[-4:-1]) . (&#39;orange&#39;, &#39;kiwi&#39;, &#39;melon&#39;) . #loop through the tuple items by using a for loop tuple3 = (&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;) for x in tuple3: print(x) . apple banana cherry . #Check if Item Exists if &quot;apple&quot; in tuple3: print(&quot;Yes&quot;) . Yes . #Print the number of items in the tuple print(len(tuple3)) . 3 . # join two or more tuples you can use the + operator tuple1 = (&quot;a&quot;, &quot;b&quot; , &quot;c&quot;) tuple2 = (1, 2, 3) tuple3 = tuple1 + tuple2 print(tuple3) . (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, 1, 2, 3) . #Using the tuple() method to make a tuple thistuple = tuple((&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;)) # note the double round-brackets print(thistuple) . (&#39;apple&#39;, &#39;banana&#39;, &#39;cherry&#39;) . 3) Set . A set is a collection which is unordered and unindexed. Sets are written with curly brackets. . set1 = {&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;} print(set1) . {&#39;banana&#39;, &#39;apple&#39;, &#39;cherry&#39;} . #Access items, Loop through the set, and print the values for x in set1: print(x) . banana apple cherry . if &quot;apple&quot; in set1: print(&quot;Yes&quot;) . Yes . Set methods: . add() Adds an element to the set | clear() Removes all the elements from the set | copy() Returns a copy of the set | difference() Returns a set containing the difference between two or more sets | difference_update() Removes the items in this set that are also included in another, specified set | discard() Remove the specified item | intersection() Returns a set, that is the intersection of two other sets | intersection_update() Removes the items in this set that are not present in other, specified set(s) | isdisjoint() Returns whether two sets have a intersection or not | issubset() Returns whether another set contains this set or not | issuperset() Returns whether this set contains another set or not | pop() Removes an element from the set | remove() Removes the specified element | symmetric_difference() Returns a set with the symmetric differences of two sets | symmetric_difference_update() inserts the symmetric differences from this set and another | union() Return a set containing the union of sets | update() Update the set with the union of this set and others | . # Adding new items set1.add(&quot;orange&quot;) print(set1) . {&#39;banana&#39;, &#39;apple&#39;, &#39;cherry&#39;, &#39;orange&#39;} . #Add multiple items to a set, using the update() method set1.update([&quot;orange&quot;, &quot;mango&quot;, &quot;grapes&quot;]) print(set1) . {&#39;banana&#39;, &#39;cherry&#39;, &#39;orange&#39;, &#39;apple&#39;, &#39;grapes&#39;, &#39;mango&#39;} . # length of the set print(len(set1)) . 6 . # remove item set1.remove(&quot;banana&quot;) print(set1) . {&#39;cherry&#39;, &#39;orange&#39;, &#39;apple&#39;, &#39;grapes&#39;, &#39;mango&#39;} . #Remove the last item by using the pop() method set2 = {&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;} x = set2.pop() print(x) print(set2) . banana {&#39;apple&#39;, &#39;cherry&#39;} . #clear() method empties the set thisset = {&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;} thisset.clear() print(thisset) . set() . #del keyword will delete the set completely thisset = {&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;} del thisset print(thisset) . NameError Traceback (most recent call last) &lt;ipython-input-67-b8e1fa6a22f4&gt; in &lt;module&gt; 5 del thisset 6 -&gt; 7 print(thisset) NameError: name &#39;thisset&#39; is not defined . #use the union() method that returns a new set containing all items from both sets, #or the update() method that inserts all the items from one set into another set1 = {&quot;a&quot;, &quot;b&quot; , &quot;c&quot;} set2 = {1, 2, 3} set3 = set1.union(set2) print(set3) . {&#39;b&#39;, 1, 2, 3, &#39;a&#39;, &#39;c&#39;} . #update() method inserts the items in set2 into set1 set1 = {&quot;a&quot;, &quot;b&quot; , &quot;c&quot;} set2 = {1, 2, 3} set1.update(set2) print(set1) . {&#39;b&#39;, 1, 2, 3, &#39;a&#39;, &#39;c&#39;} . 4) Dictionary . A dictionary is a collection which is unordered, changeable and indexed. . dict = { &quot;brand&quot;: &quot;Ford&quot;, &quot;model&quot;: &quot;Mustang&quot;, &quot;year&quot;: 1964 } print(dict) . {&#39;brand&#39;: &#39;Ford&#39;, &#39;model&#39;: &#39;Mustang&#39;, &#39;year&#39;: 1964} . #access the items of a dictionary by referring to its key name, inside square brackets dict[&quot;model&quot;] . &#39;Mustang&#39; . Dict methods . clear() Removes all the elements from the dictionary | copy() Returns a copy of the dictionary | fromkeys() Returns a dictionary with the specified keys and value | get() Returns the value of the specified key | items() Returns a list containing a tuple for each key value pair | keys() Returns a list containing the dictionary&#39;s keys | pop() Removes the element with the specified key | popitem() Removes the last inserted key-value pair | setdefault() Returns the value of the specified key. If the key does not exist: insert the key, with the specified value | update() Updates the dictionary with the specified key-value pairs | values() Returns a list of all the values in the dictionary | . #use get() to get the same result dict.get(&quot;model&quot;) . &#39;Mustang&#39; . #change the value of a specific item by referring to its key name dict1 = { &quot;brand&quot;: &quot;Ford&quot;, &quot;model&quot;: &quot;Mustang&quot;, &quot;year&quot;: 1964 } dict1[&quot;year&quot;] = 2018 print(dict1) . {&#39;brand&#39;: &#39;Ford&#39;, &#39;model&#39;: &#39;Mustang&#39;, &#39;year&#39;: 2018} . #loop through a dictionary by using a for loop for x in dict1: print(x) . brand model year . #Print all values in the dictionary, one by one for x in dict1: print(dict1[x]) . Ford Mustang 2018 . #use the values() method to return values of a dictionary for x in dict1.values(): print(x) . Ford Mustang 2018 . #Loop through both keys and values, by using the items() method for x, y in dict1.items(): print(x, y) . brand Ford model Mustang year 2018 . #Check if an item present in the dictionary if &quot;model&quot; in dict1: print(&quot;Yes&quot;) . Yes . print(len(dict1)) . 3 . #adding items thisdict = { &quot;brand&quot;: &quot;Ford&quot;, &quot;model&quot;: &quot;Mustang&quot;, &quot;year&quot;: 1964 } thisdict[&quot;color&quot;] = &quot;red&quot; print(thisdict) . {&#39;brand&#39;: &#39;Ford&#39;, &#39;model&#39;: &#39;Mustang&#39;, &#39;year&#39;: 1964, &#39;color&#39;: &#39;red&#39;} . #pop() method removes the item with the specified key name thisdict = { &quot;brand&quot;: &quot;Ford&quot;, &quot;model&quot;: &quot;Mustang&quot;, &quot;year&quot;: 1964 } thisdict.pop(&quot;model&quot;) print(thisdict) . {&#39;brand&#39;: &#39;Ford&#39;, &#39;year&#39;: 1964} . # popitem() method removes the last inserted item thisdict = { &quot;brand&quot;: &quot;Ford&quot;, &quot;model&quot;: &quot;Mustang&quot;, &quot;year&quot;: 1964 } thisdict.popitem() print(thisdict) . {&#39;brand&#39;: &#39;Ford&#39;, &#39;model&#39;: &#39;Mustang&#39;} . #del keyword removes the item with the specified key name thisdict = { &quot;brand&quot;: &quot;Ford&quot;, &quot;model&quot;: &quot;Mustang&quot;, &quot;year&quot;: 1964 } del thisdict[&quot;model&quot;] print(thisdict) . {&#39;brand&#39;: &#39;Ford&#39;, &#39;year&#39;: 1964} . #dictionary can also contain many dictionaries, this is called nested dictionaries myfamily = { &quot;child1&quot; : { &quot;name&quot; : &quot;Emil&quot;, &quot;year&quot; : 2004 }, &quot;child2&quot; : { &quot;name&quot; : &quot;Tobias&quot;, &quot;year&quot; : 2007 }, &quot;child3&quot; : { &quot;name&quot; : &quot;Linus&quot;, &quot;year&quot; : 2011 } } . #Create three dictionaries, then create one dictionary that will contain the other three dictionaries child1 = { &quot;name&quot; : &quot;Emil&quot;, &quot;year&quot; : 2004 } child2 = { &quot;name&quot; : &quot;Tobias&quot;, &quot;year&quot; : 2007 } child3 = { &quot;name&quot; : &quot;Linus&quot;, &quot;year&quot; : 2011 } myfamily = { &quot;child1&quot; : child1, &quot;child2&quot; : child2, &quot;child3&quot; : child3 } . Python Conditions . If statement . a = 100 b = 200 if b &gt; a: print(&quot;b is greater than a&quot;) . b is greater than a . #simplyfied: a = 100 b = 200 if a &lt; b: print(&quot;a is greater than b&quot;) . a is greater than b . a = 20 b = 20 if b &gt; a: print(&quot;b is greater than a&quot;) elif a == b: print(&quot;a and b are equal&quot;) . a and b are equal . a = 200 b = 100 if b &gt; a: print(&quot;b is greater than a&quot;) elif a == b: print(&quot;a and b are equal&quot;) else: print(&quot;a is greater than b&quot;) . a is greater than b . # simplyfied: a = 100 b = 300 print(&quot;A&quot;) if a &gt; b else print(&quot;B&quot;) . B . AND and OR Statement . a = 200 b = 33 c = 500 if a &gt; b and c &gt; a: print(&quot;Both conditions are True&quot;) . Both conditions are True . a = 200 b = 33 c = 500 if a &gt; b or a &gt; c: print(&quot;At least one of the conditions is True&quot;) . At least one of the conditions is True . Nested If . x = 41 . if x &gt; 10: print(&quot;Above ten,&quot;) if x &gt; 20: print(&quot;and also above 20!&quot;) else: print(&quot;but not above 20.&quot;) . Pass . #if statements cannot be empty, but if you for some reason have an if statement #with no content, put in the pass statement to avoid getting an error a = 33 b = 200 if b &gt; a: pass . The while Loop . i = 1 while i &lt; 6: print(i) i += 1 . 1 2 3 4 5 . Break Statement . i = 1 while i &lt; 6: print(i) if i == 3: break i += 1 . 1 2 3 . # with Continue i = 0 while i &lt; 6: i += 1 if i == 3: continue print(i) . 1 2 4 5 6 . ### Else statement i = 1 while i &lt; 6: print(i) i += 1 else: print(&quot;i is no longer less than 6&quot;) . 1 2 3 4 5 i is no longer less than 6 . For Loops . # For loop for List fruits = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;] for x in fruits: print(x) . apple banana cherry . # strings for x in &quot;banana&quot;: print(x) . b a n a n a . #break statement fruits = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;] for x in fruits: print(x) if x == &quot;banana&quot;: break . apple banana . fruits = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;] for x in fruits: if x == &quot;banana&quot;: break print(x) . apple . #continue fruits = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;] for x in fruits: if x == &quot;banana&quot;: continue print(x) . apple cherry . # Range for x in range(6): print(x) . 0 1 2 3 4 5 . for x in range(2, 6): print(x) . 2 3 4 5 . for x in range(2, 30, 3): print(x) . 2 5 8 11 14 17 20 23 26 29 . for x in range(6): print(x) else: print(&quot;Finally finished!&quot;) . 0 1 2 3 4 5 Finally finished! . adj = [&quot;red&quot;, &quot;big&quot;, &quot;tasty&quot;] fruits = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;] for x in adj: for y in fruits: print(x, y) . red apple red banana red cherry big apple big banana big cherry tasty apple tasty banana tasty cherry . for x in [0, 1, 2]: pass . Creating a Function . def my_function(): print(&quot;Hello&quot;) my_function() . Hello . def my_function(*kids): print(&quot;The youngest child is &quot; + kids[2]) my_function(&quot;Emil&quot;, &quot;Tobias&quot;, &quot;Linus&quot;) . The youngest child is Linus . def my_function(child3, child2, child1): print(&quot;The youngest child is &quot; + child3) my_function(child1 = &quot;Emil&quot;, child2 = &quot;Tobias&quot;, child3 = &quot;Linus&quot;) . The youngest child is Linus . #Passing a List as an Argument def my_function(food): for x in food: print(x) fruits = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;] my_function(fruits) . apple banana cherry . #return value def my_function(x): return 5 * x print(my_function(3)) . 15 . #Recursion Example def tri_recursion(k): if(k &gt; 0): result = k + tri_recursion(k - 1) print(result) else: result = 0 return result print(&quot; n nRecursion Example Results&quot;) tri_recursion(6) . Recursion Example Results 1 3 6 10 15 21 . 21 . lambda function . x = lambda a, b, c : a + b + c print(x(5, 6, 2)) . 13 . def myfunc(n): return lambda a : a * n . def myfunc(n): return lambda a : a * n mydoubler = myfunc(2) print(mydoubler(11)) . 22 . def myfunc(n): return lambda a : a * n mydoubler = myfunc(2) mytripler = myfunc(3) print(mydoubler(11)) print(mytripler(11)) . 22 33 . Open a File on the Server . Reading files . #f = open(&quot;demofile.txt&quot;, &quot;r&quot;) #print(f.read()) #f = open(&quot;D: myfiles welcome.txt&quot;, &quot;r&quot;) #print(f.read()) . #Read one line of the file #f = open(&quot;demofile.txt&quot;, &quot;r&quot;) #print(f.readline()) . #Loop through the file line by line #f = open(&quot;demofile.txt&quot;, &quot;r&quot;) #for x in f: # print(x) . #Close the file when you are finish with it #f = open(&quot;demofile.txt&quot;, &quot;r&quot;) #print(f.readline()) #f.close() . Writing files: . #Open the file &quot;demofile2.txt&quot; and append content to the file #f = open(&quot;demofile2.txt&quot;, &quot;a&quot;) #f.write(&quot;Now the file has more content!&quot;) #f.close() #open and read the file after the appending: #f = open(&quot;demofile2.txt&quot;, &quot;r&quot;) #print(f.read()) . #Open the file &quot;demofile3.txt&quot; and overwrite the content #f = open(&quot;demofile3.txt&quot;, &quot;w&quot;) #f.write(&quot;Woops! I have deleted the content!&quot;) #f.close() #open and read the file after the appending: #f = open(&quot;demofile3.txt&quot;, &quot;r&quot;) #print(f.read()) . #Create a file called &quot;myfile.txt&quot; #f = open(&quot;myfile.txt&quot;, &quot;x&quot;) . #Remove the file &quot;demofile.txt&quot; #import os #os.remove(&quot;demofile.txt&quot;) . #Check if file exists, then delete it: #import os #if os.path.exists(&quot;demofile.txt&quot;): # os.remove(&quot;demofile.txt&quot;) #else: # print(&quot;The file does not exist&quot;) . #Try to open and write to a file that is not writable: #try: # f = open(&quot;demofile.txt&quot;) # f.write(&quot;Lorum Ipsum&quot;) #except: # print(&quot;Something went wrong when writing to the file&quot;) #finally: # f.close() . #Raise an error and stop the program if x is lower than 0: #x = -1 #if x &lt; 0: # raise Exception(&quot;Sorry, no numbers below zero&quot;) . #Raise a TypeError if x is not an integer: #x = &quot;hello&quot; #if not type(x) is int: # raise TypeError(&quot;Only integers are allowed&quot;) . . NumPy . import numpy as np . simple_list = [1,2,3] . np.array(simple_list) . array([1, 2, 3]) . list_of_lists = [[1,2,3], [4,5,6], [7,8,9]] . np.array(list_of_lists) . array([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) . np.arange(0,10) . array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) . np.arange(0,21,5) . array([ 0, 5, 10, 15, 20]) . np.zeros(50) . array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.]) . np.ones((4,5)) . array([[1., 1., 1., 1., 1.], [1., 1., 1., 1., 1.], [1., 1., 1., 1., 1.], [1., 1., 1., 1., 1.]]) . np.linspace(0,20,10) . array([ 0. , 2.22222222, 4.44444444, 6.66666667, 8.88888889, 11.11111111, 13.33333333, 15.55555556, 17.77777778, 20. ]) . np.eye(5) . array([[1., 0., 0., 0., 0.], [0., 1., 0., 0., 0.], [0., 0., 1., 0., 0.], [0., 0., 0., 1., 0.], [0., 0., 0., 0., 1.]]) . np.random.rand(3,2) . array([[0.24202235, 0.57396416], [0.0400231 , 0.38224147], [0.30024483, 0.20187655]]) . np.random.randint(5,20,10) . array([10, 14, 18, 11, 9, 15, 16, 19, 13, 9]) . np.arange(30) . array([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29]) . np.random.randint(0,100,20) . array([81, 69, 90, 47, 3, 97, 31, 9, 58, 77, 92, 64, 73, 37, 65, 66, 9, 21, 25, 73]) . sample_array = np.arange(30) sample_array.reshape(5,6) . array([[ 0, 1, 2, 3, 4, 5], [ 6, 7, 8, 9, 10, 11], [12, 13, 14, 15, 16, 17], [18, 19, 20, 21, 22, 23], [24, 25, 26, 27, 28, 29]]) . rand_array = np.random.randint(0,100,20) rand_array.argmin() . 12 . sample_array.shape . (30,) . sample_array.reshape(1,30) . array([[ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29]]) . sample_array.reshape(30,1) . array([[ 0], [ 1], [ 2], [ 3], [ 4], [ 5], [ 6], [ 7], [ 8], [ 9], [10], [11], [12], [13], [14], [15], [16], [17], [18], [19], [20], [21], [22], [23], [24], [25], [26], [27], [28], [29]]) . sample_array.dtype . dtype(&#39;int32&#39;) . a = np.random.randn(2,3) a.T . array([[-1.866579 , -0.77167212], [-0.24050824, -1.86954729], [ 1.09606272, 0.5064306 ]]) . sample_array = np.arange(10,21) . sample_array . array([10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]) . sample_array[[2,5]] . array([12, 15]) . sample_array[1:2] = 100 . sample_array . array([ 10, 100, 12, 13, 14, 15, 16, 17, 18, 19, 20]) . sample_array = np.arange(10,21) . sample_array[0:7] . array([10, 11, 12, 13, 14, 15, 16]) . sample_array = np.arange(10,21) sample_array . array([10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]) . subset_sample_array = sample_array[0:7] subset_sample_array . array([10, 11, 12, 13, 14, 15, 16]) . subset_sample_array[:]=1001 . subset_sample_array . array([1001, 1001, 1001, 1001, 1001, 1001, 1001]) . sample_array . array([1001, 1001, 1001, 1001, 1001, 1001, 1001, 17, 18, 19, 20]) . copy_sample_array = sample_array.copy() . copy_sample_array . array([1001, 1001, 1001, 1001, 1001, 1001, 1001, 17, 18, 19, 20]) . copy_sample_array[:]=10 copy_sample_array . array([10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10]) . sample_array . array([1001, 1001, 1001, 1001, 1001, 1001, 1001, 17, 18, 19, 20]) . sample_matrix = np.array(([50,20,1,23], [24,23,21,32], [76,54,32,12], [98,6,4,3])) . sample_matrix . array([[50, 20, 1, 23], [24, 23, 21, 32], [76, 54, 32, 12], [98, 6, 4, 3]]) . sample_matrix[0][3] . 23 . sample_matrix[0,3] . 23 . sample_matrix[3,:] . array([98, 6, 4, 3]) . sample_matrix[3] . array([98, 6, 4, 3]) . sample_matrix = np.array(([50,20,1,23,34], [24,23,21,32,34], [76,54,32,12,98], [98,6,4,3,67], [12,23,34,56,67])) . sample_matrix . array([[50, 20, 1, 23, 34], [24, 23, 21, 32, 34], [76, 54, 32, 12, 98], [98, 6, 4, 3, 67], [12, 23, 34, 56, 67]]) . sample_matrix[:,[1,3]] . array([[20, 23], [23, 32], [54, 12], [ 6, 3], [23, 56]]) . sample_matrix[:,(3,1)] . array([[23, 20], [32, 23], [12, 54], [ 3, 6], [56, 23]]) . sample_array=np.arange(1,31) . sample_array . array([ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30]) . bool = sample_array &lt; 10 . sample_array[bool] . array([1, 2, 3, 4, 5, 6, 7, 8, 9]) . sample_array[sample_array &lt;10] . array([1, 2, 3, 4, 5, 6, 7, 8, 9]) . a=11 . sample_array[sample_array &lt; a] . array([ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) . sample_array + sample_array . array([ 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60]) . sample_array / sample_array . array([1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1.]) . 10/sample_array . array([10. , 5. , 3.33333333, 2.5 , 2. , 1.66666667, 1.42857143, 1.25 , 1.11111111, 1. , 0.90909091, 0.83333333, 0.76923077, 0.71428571, 0.66666667, 0.625 , 0.58823529, 0.55555556, 0.52631579, 0.5 , 0.47619048, 0.45454545, 0.43478261, 0.41666667, 0.4 , 0.38461538, 0.37037037, 0.35714286, 0.34482759, 0.33333333]) . sample_array + 1 . array([ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31]) . np.var(sample_array) . 74.91666666666667 . array = np.random.randn(6,6) . array . array([[-1.2513939 , 0.63036933, 1.34352857, 0.69169362, 0.01026876, 0.59189891], [-1.17904234, -0.12504466, 0.31374784, 0.09035803, -0.61388114, 1.1150514 ], [ 1.06328715, 0.46405969, 0.00697848, -2.29704625, 0.96100601, 0.83872649], [ 0.3548689 , -0.20216495, -1.17393345, 0.04961487, -0.67034172, 0.55421924], [-2.2873708 , -1.24865618, -0.5852612 , -1.14245419, 0.63155215, -0.86846749], [-0.19474274, 0.26641693, -1.72485259, 1.13081737, -0.48967084, -0.56814362]]) . np.std(array) . 0.9421603403314502 . np.mean(array) . -0.15316678701199804 . sports = np.array([&#39;golf&#39;, &#39;cric&#39;, &#39;fball&#39;, &#39;cric&#39;, &#39;Cric&#39;, &#39;fooseball&#39;]) np.unique(sports) . array([&#39;Cric&#39;, &#39;cric&#39;, &#39;fball&#39;, &#39;fooseball&#39;, &#39;golf&#39;], dtype=&#39;&lt;U9&#39;) . sample_array . array([ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30]) . simple_array = np.arange(0,20) . simple_array . array([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]) . np.save(&#39;sample_array&#39;, sample_array) . np.savez(&#39;2_arrays.npz&#39;, a=sample_array, b=simple_array) . np.load(&#39;sample_array.npy&#39;) . array([ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30]) . archive = np.load(&#39;2_arrays.npz&#39;) . archive[&#39;b&#39;] . array([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]) . np.savetxt(&#39;text_file.txt&#39;, sample_array,delimiter=&#39;,&#39;) . np.loadtxt(&#39;text_file.txt&#39;, delimiter=&#39;,&#39;) . array([ 1., 2., 3., 4., 5., 6., 7., 8., 9., 10., 11., 12., 13., 14., 15., 16., 17., 18., 19., 20., 21., 22., 23., 24., 25., 26., 27., 28., 29., 30.]) . data = {&#39;prodID&#39;: [&#39;101&#39;, &#39;102&#39;, &#39;103&#39;, &#39;104&#39;, &#39;104&#39;], &#39;prodname&#39;: [&#39;X&#39;, &#39;Y&#39;, &#39;Z&#39;, &#39;X&#39;, &#39;W&#39;], &#39;profit&#39;: [&#39;2738&#39;, &#39;2727&#39;, &#39;3497&#39;, &#39;7347&#39;, &#39;3743&#39;]} . . Pandas . import pandas as pd . score = [10, 15, 20, 25] . pd.Series(data=score, index = [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;]) . a 10 b 15 c 20 d 25 dtype: int64 . demo_matrix = np.array(([13,35,74,48], [23,37,37,38], [73,39,93,39])) . demo_matrix . array([[13, 35, 74, 48], [23, 37, 37, 38], [73, 39, 93, 39]]) . demo_matrix[2,3] . 39 . np.arange(0,22,6) . array([ 0, 6, 12, 18]) . demo_array=np.arange(0,10) . demo_array . array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) . demo_array &lt;3 . array([ True, True, True, False, False, False, False, False, False, False]) . demo_array[demo_array &lt;6] . array([0, 1, 2, 3, 4, 5]) . np.max(demo_array) . 9 . s1 = pd.Series([&#39;a&#39;, &#39;b&#39;]) . s2 = pd.Series([&#39;c&#39;, &#39;d&#39;]) . pd.concat([s1+s2]) . 0 ac 1 bd dtype: object . Creating a Series using Pandas . You could convert a list,numpy array, or dictionary to a Series in the following manner . labels = [&#39;w&#39;,&#39;x&#39;,&#39;y&#39;,&#39;z&#39;] list = [10,20,30,40] array = np.array([10,20,30,40]) dict = {&#39;w&#39;:10,&#39;x&#39;:20,&#39;y&#39;:30,&#39;z&#39;:40} . pd.Series(data=list) . 0 10 1 20 2 30 3 40 dtype: int64 . pd.Series(data=list,index=labels) . w 10 x 20 y 30 z 40 dtype: int64 . pd.Series(list,labels) . w 10 x 20 y 30 z 40 dtype: int64 . pd.Series(array) . 0 10 1 20 2 30 3 40 dtype: int32 . pd.Series(array,labels) . w 10 x 20 y 30 z 40 dtype: int32 . pd.Series(dict) . w 10 x 20 y 30 z 40 dtype: int64 . Using an Index . We shall now see how to index in a Series using the following examples of 2 series . sports1 = pd.Series([1,2,3,4],index = [&#39;Cricket&#39;, &#39;Football&#39;,&#39;Basketball&#39;, &#39;Golf&#39;]) . sports1 . Cricket 1 Football 2 Basketball 3 Golf 4 dtype: int64 . sports2 = pd.Series([1,2,5,4],index = [&#39;Cricket&#39;, &#39;Football&#39;,&#39;Baseball&#39;, &#39;Golf&#39;]) . sports2 . Cricket 1 Football 2 Baseball 5 Golf 4 dtype: int64 . sports1 + sports2 . Baseball NaN Basketball NaN Cricket 2.0 Football 4.0 Golf 8.0 dtype: float64 . DataFrames . DataFrames concept in python is similar to that of R programming language. DataFrame is a collection of Series combined together to share the same index positions. . from numpy.random import randn np.random.seed(1) . dataframe = pd.DataFrame(randn(10,5),index=&#39;A B C D E F G H I J&#39;.split(),columns=&#39;Score1 Score2 Score3 Score4 Score5&#39;.split()) . dataframe . Score1 Score2 Score3 Score4 Score5 . A | 1.624345 | -0.611756 | -0.528172 | -1.072969 | 0.865408 | . B | -2.301539 | 1.744812 | -0.761207 | 0.319039 | -0.249370 | . C | 1.462108 | -2.060141 | -0.322417 | -0.384054 | 1.133769 | . D | -1.099891 | -0.172428 | -0.877858 | 0.042214 | 0.582815 | . E | -1.100619 | 1.144724 | 0.901591 | 0.502494 | 0.900856 | . F | -0.683728 | -0.122890 | -0.935769 | -0.267888 | 0.530355 | . G | -0.691661 | -0.396754 | -0.687173 | -0.845206 | -0.671246 | . H | -0.012665 | -1.117310 | 0.234416 | 1.659802 | 0.742044 | . I | -0.191836 | -0.887629 | -0.747158 | 1.692455 | 0.050808 | . J | -0.636996 | 0.190915 | 2.100255 | 0.120159 | 0.617203 | . Selection and Indexing . Ways in which we can grab data from a DataFrame . dataframe[&#39;Score3&#39;] . A -0.528172 B -0.761207 C -0.322417 D -0.877858 E 0.901591 F -0.935769 G -0.687173 H 0.234416 I -0.747158 J 2.100255 Name: Score3, dtype: float64 . # Pass a list of column names in any order necessary dataframe[[&#39;Score2&#39;,&#39;Score1&#39;]] . Score2 Score1 . A | -0.611756 | 1.624345 | . B | 1.744812 | -2.301539 | . C | -2.060141 | 1.462108 | . D | -0.172428 | -1.099891 | . E | 1.144724 | -1.100619 | . F | -0.122890 | -0.683728 | . G | -0.396754 | -0.691661 | . H | -1.117310 | -0.012665 | . I | -0.887629 | -0.191836 | . J | 0.190915 | -0.636996 | . #DataFrame Columns are nothing but a Series each type(dataframe[&#39;Score1&#39;]) . pandas.core.series.Series . Adding a new column to the DataFrame . dataframe[&#39;Score6&#39;] = dataframe[&#39;Score1&#39;] + dataframe[&#39;Score2&#39;] . dataframe . Score1 Score2 Score3 Score4 Score5 Score6 . A | 1.624345 | -0.611756 | -0.528172 | -1.072969 | 0.865408 | 1.012589 | . B | -2.301539 | 1.744812 | -0.761207 | 0.319039 | -0.249370 | -0.556727 | . C | 1.462108 | -2.060141 | -0.322417 | -0.384054 | 1.133769 | -0.598033 | . D | -1.099891 | -0.172428 | -0.877858 | 0.042214 | 0.582815 | -1.272319 | . E | -1.100619 | 1.144724 | 0.901591 | 0.502494 | 0.900856 | 0.044105 | . F | -0.683728 | -0.122890 | -0.935769 | -0.267888 | 0.530355 | -0.806618 | . G | -0.691661 | -0.396754 | -0.687173 | -0.845206 | -0.671246 | -1.088414 | . H | -0.012665 | -1.117310 | 0.234416 | 1.659802 | 0.742044 | -1.129975 | . I | -0.191836 | -0.887629 | -0.747158 | 1.692455 | 0.050808 | -1.079465 | . J | -0.636996 | 0.190915 | 2.100255 | 0.120159 | 0.617203 | -0.446080 | . Removing Columns from DataFrame . # Use axis=0 for dropping rows and axis=1 for dropping columns dataframe.drop(&#39;Score6&#39;,axis=1) . Score1 Score2 Score3 Score4 Score5 . A | 1.624345 | -0.611756 | -0.528172 | -1.072969 | 0.865408 | . B | -2.301539 | 1.744812 | -0.761207 | 0.319039 | -0.249370 | . C | 1.462108 | -2.060141 | -0.322417 | -0.384054 | 1.133769 | . D | -1.099891 | -0.172428 | -0.877858 | 0.042214 | 0.582815 | . E | -1.100619 | 1.144724 | 0.901591 | 0.502494 | 0.900856 | . F | -0.683728 | -0.122890 | -0.935769 | -0.267888 | 0.530355 | . G | -0.691661 | -0.396754 | -0.687173 | -0.845206 | -0.671246 | . H | -0.012665 | -1.117310 | 0.234416 | 1.659802 | 0.742044 | . I | -0.191836 | -0.887629 | -0.747158 | 1.692455 | 0.050808 | . J | -0.636996 | 0.190915 | 2.100255 | 0.120159 | 0.617203 | . # column is not dropped unless inplace input is TRUE dataframe . Score1 Score2 Score3 Score4 Score5 Score6 . A | 1.624345 | -0.611756 | -0.528172 | -1.072969 | 0.865408 | 1.012589 | . B | -2.301539 | 1.744812 | -0.761207 | 0.319039 | -0.249370 | -0.556727 | . C | 1.462108 | -2.060141 | -0.322417 | -0.384054 | 1.133769 | -0.598033 | . D | -1.099891 | -0.172428 | -0.877858 | 0.042214 | 0.582815 | -1.272319 | . E | -1.100619 | 1.144724 | 0.901591 | 0.502494 | 0.900856 | 0.044105 | . F | -0.683728 | -0.122890 | -0.935769 | -0.267888 | 0.530355 | -0.806618 | . G | -0.691661 | -0.396754 | -0.687173 | -0.845206 | -0.671246 | -1.088414 | . H | -0.012665 | -1.117310 | 0.234416 | 1.659802 | 0.742044 | -1.129975 | . I | -0.191836 | -0.887629 | -0.747158 | 1.692455 | 0.050808 | -1.079465 | . J | -0.636996 | 0.190915 | 2.100255 | 0.120159 | 0.617203 | -0.446080 | . dataframe.drop(&#39;Score6&#39;,axis=1,inplace=True) dataframe . Score1 Score2 Score3 Score4 Score5 . A | 1.624345 | -0.611756 | -0.528172 | -1.072969 | 0.865408 | . B | -2.301539 | 1.744812 | -0.761207 | 0.319039 | -0.249370 | . C | 1.462108 | -2.060141 | -0.322417 | -0.384054 | 1.133769 | . D | -1.099891 | -0.172428 | -0.877858 | 0.042214 | 0.582815 | . E | -1.100619 | 1.144724 | 0.901591 | 0.502494 | 0.900856 | . F | -0.683728 | -0.122890 | -0.935769 | -0.267888 | 0.530355 | . G | -0.691661 | -0.396754 | -0.687173 | -0.845206 | -0.671246 | . H | -0.012665 | -1.117310 | 0.234416 | 1.659802 | 0.742044 | . I | -0.191836 | -0.887629 | -0.747158 | 1.692455 | 0.050808 | . J | -0.636996 | 0.190915 | 2.100255 | 0.120159 | 0.617203 | . Dropping rows using axis=0 . # Row will also be dropped only if inplace=TRUE is given as input dataframe.drop(&#39;A&#39;,axis=0) . Score1 Score2 Score3 Score4 Score5 . B | -2.301539 | 1.744812 | -0.761207 | 0.319039 | -0.249370 | . C | 1.462108 | -2.060141 | -0.322417 | -0.384054 | 1.133769 | . D | -1.099891 | -0.172428 | -0.877858 | 0.042214 | 0.582815 | . E | -1.100619 | 1.144724 | 0.901591 | 0.502494 | 0.900856 | . F | -0.683728 | -0.122890 | -0.935769 | -0.267888 | 0.530355 | . G | -0.691661 | -0.396754 | -0.687173 | -0.845206 | -0.671246 | . H | -0.012665 | -1.117310 | 0.234416 | 1.659802 | 0.742044 | . I | -0.191836 | -0.887629 | -0.747158 | 1.692455 | 0.050808 | . J | -0.636996 | 0.190915 | 2.100255 | 0.120159 | 0.617203 | . Selecting Rows . dataframe.loc[&#39;F&#39;] . Score1 -0.683728 Score2 -0.122890 Score3 -0.935769 Score4 -0.267888 Score5 0.530355 Name: F, dtype: float64 . select based off of index position instead of label - use iloc instead of loc function . dataframe.iloc[2] . Score1 1.462108 Score2 -2.060141 Score3 -0.322417 Score4 -0.384054 Score5 1.133769 Name: C, dtype: float64 . Selecting subset of rows and columns using loc function . dataframe.loc[&#39;A&#39;,&#39;Score1&#39;] . 1.6243453636632417 . dataframe.loc[[&#39;A&#39;,&#39;B&#39;],[&#39;Score1&#39;,&#39;Score2&#39;]] . Score1 Score2 . A | 1.624345 | -0.611756 | . B | -2.301539 | 1.744812 | . Conditional Selection . Similar to NumPy, we can make conditional selections using Brackets . dataframe&gt;0.5 . Score1 Score2 Score3 Score4 Score5 . A | True | False | False | False | True | . B | False | True | False | False | False | . C | True | False | False | False | True | . D | False | False | False | False | True | . E | False | True | True | True | True | . F | False | False | False | False | True | . G | False | False | False | False | False | . H | False | False | False | True | True | . I | False | False | False | True | False | . J | False | False | True | False | True | . dataframe[dataframe&gt;0.5] . Score1 Score2 Score3 Score4 Score5 . A | 1.624345 | NaN | NaN | NaN | 0.865408 | . B | NaN | 1.744812 | NaN | NaN | NaN | . C | 1.462108 | NaN | NaN | NaN | 1.133769 | . D | NaN | NaN | NaN | NaN | 0.582815 | . E | NaN | 1.144724 | 0.901591 | 0.502494 | 0.900856 | . F | NaN | NaN | NaN | NaN | 0.530355 | . G | NaN | NaN | NaN | NaN | NaN | . H | NaN | NaN | NaN | 1.659802 | 0.742044 | . I | NaN | NaN | NaN | 1.692455 | NaN | . J | NaN | NaN | 2.100255 | NaN | 0.617203 | . dataframe[dataframe[&#39;Score1&#39;]&gt;0.5] . Score1 Score2 Score3 Score4 Score5 . A | 1.624345 | -0.611756 | -0.528172 | -1.072969 | 0.865408 | . C | 1.462108 | -2.060141 | -0.322417 | -0.384054 | 1.133769 | . dataframe[dataframe[&#39;Score1&#39;]&gt;0.5][&#39;Score2&#39;] . A -0.611756 C -2.060141 Name: Score2, dtype: float64 . dataframe[dataframe[&#39;Score1&#39;]&gt;0.5][[&#39;Score2&#39;,&#39;Score3&#39;]] . Score2 Score3 . A | -0.611756 | -0.528172 | . C | -2.060141 | -0.322417 | . Some more features of indexing includes . resetting the index | setting a different value | index hierarchy | . # Reset to default index value instead of A to J dataframe.reset_index() . Countries Score1 Score2 Score3 Score4 Score5 . 0 | IND | 1.624345 | -0.611756 | -0.528172 | -1.072969 | 0.865408 | . 1 | JP | -2.301539 | 1.744812 | -0.761207 | 0.319039 | -0.249370 | . 2 | CAN | 1.462108 | -2.060141 | -0.322417 | -0.384054 | 1.133769 | . 3 | GE | -1.099891 | -0.172428 | -0.877858 | 0.042214 | 0.582815 | . 4 | IT | -1.100619 | 1.144724 | 0.901591 | 0.502494 | 0.900856 | . 5 | PL | -0.683728 | -0.122890 | -0.935769 | -0.267888 | 0.530355 | . 6 | FY | -0.691661 | -0.396754 | -0.687173 | -0.845206 | -0.671246 | . 7 | IU | -0.012665 | -1.117310 | 0.234416 | 1.659802 | 0.742044 | . 8 | RT | -0.191836 | -0.887629 | -0.747158 | 1.692455 | 0.050808 | . 9 | IP | -0.636996 | 0.190915 | 2.100255 | 0.120159 | 0.617203 | . # Setting new index value newindex = &#39;IND JP CAN GE IT PL FY IU RT IP&#39;.split() . dataframe[&#39;Countries&#39;] = newindex dataframe . Score1 Score2 Score3 Score4 Score5 Countries . Countries . IND | 1.624345 | -0.611756 | -0.528172 | -1.072969 | 0.865408 | IND | . JP | -2.301539 | 1.744812 | -0.761207 | 0.319039 | -0.249370 | JP | . CAN | 1.462108 | -2.060141 | -0.322417 | -0.384054 | 1.133769 | CAN | . GE | -1.099891 | -0.172428 | -0.877858 | 0.042214 | 0.582815 | GE | . IT | -1.100619 | 1.144724 | 0.901591 | 0.502494 | 0.900856 | IT | . PL | -0.683728 | -0.122890 | -0.935769 | -0.267888 | 0.530355 | PL | . FY | -0.691661 | -0.396754 | -0.687173 | -0.845206 | -0.671246 | FY | . IU | -0.012665 | -1.117310 | 0.234416 | 1.659802 | 0.742044 | IU | . RT | -0.191836 | -0.887629 | -0.747158 | 1.692455 | 0.050808 | RT | . IP | -0.636996 | 0.190915 | 2.100255 | 0.120159 | 0.617203 | IP | . dataframe.set_index(&#39;Countries&#39;) . Score1 Score2 Score3 Score4 Score5 . Countries . IND | 1.624345 | -0.611756 | -0.528172 | -1.072969 | 0.865408 | . JP | -2.301539 | 1.744812 | -0.761207 | 0.319039 | -0.249370 | . CAN | 1.462108 | -2.060141 | -0.322417 | -0.384054 | 1.133769 | . GE | -1.099891 | -0.172428 | -0.877858 | 0.042214 | 0.582815 | . IT | -1.100619 | 1.144724 | 0.901591 | 0.502494 | 0.900856 | . PL | -0.683728 | -0.122890 | -0.935769 | -0.267888 | 0.530355 | . FY | -0.691661 | -0.396754 | -0.687173 | -0.845206 | -0.671246 | . IU | -0.012665 | -1.117310 | 0.234416 | 1.659802 | 0.742044 | . RT | -0.191836 | -0.887629 | -0.747158 | 1.692455 | 0.050808 | . IP | -0.636996 | 0.190915 | 2.100255 | 0.120159 | 0.617203 | . # Once again, ensure that you input inplace=TRUE dataframe . Score1 Score2 Score3 Score4 Score5 Countries . Countries . IND | 1.624345 | -0.611756 | -0.528172 | -1.072969 | 0.865408 | IND | . JP | -2.301539 | 1.744812 | -0.761207 | 0.319039 | -0.249370 | JP | . CAN | 1.462108 | -2.060141 | -0.322417 | -0.384054 | 1.133769 | CAN | . GE | -1.099891 | -0.172428 | -0.877858 | 0.042214 | 0.582815 | GE | . IT | -1.100619 | 1.144724 | 0.901591 | 0.502494 | 0.900856 | IT | . PL | -0.683728 | -0.122890 | -0.935769 | -0.267888 | 0.530355 | PL | . FY | -0.691661 | -0.396754 | -0.687173 | -0.845206 | -0.671246 | FY | . IU | -0.012665 | -1.117310 | 0.234416 | 1.659802 | 0.742044 | IU | . RT | -0.191836 | -0.887629 | -0.747158 | 1.692455 | 0.050808 | RT | . IP | -0.636996 | 0.190915 | 2.100255 | 0.120159 | 0.617203 | IP | . dataframe.set_index(&#39;Countries&#39;,inplace=True) . dataframe . Score1 Score2 Score3 Score4 Score5 . Countries . IND | 1.624345 | -0.611756 | -0.528172 | -1.072969 | 0.865408 | . JP | -2.301539 | 1.744812 | -0.761207 | 0.319039 | -0.249370 | . CAN | 1.462108 | -2.060141 | -0.322417 | -0.384054 | 1.133769 | . GE | -1.099891 | -0.172428 | -0.877858 | 0.042214 | 0.582815 | . IT | -1.100619 | 1.144724 | 0.901591 | 0.502494 | 0.900856 | . PL | -0.683728 | -0.122890 | -0.935769 | -0.267888 | 0.530355 | . FY | -0.691661 | -0.396754 | -0.687173 | -0.845206 | -0.671246 | . IU | -0.012665 | -1.117310 | 0.234416 | 1.659802 | 0.742044 | . RT | -0.191836 | -0.887629 | -0.747158 | 1.692455 | 0.050808 | . IP | -0.636996 | 0.190915 | 2.100255 | 0.120159 | 0.617203 | . Missing Data . Methods to deal with missing data in Pandas . dataframe = pd.DataFrame({&#39;Cricket&#39;:[1,2,np.nan,4,6,7,2,np.nan], &#39;Baseball&#39;:[5,np.nan,np.nan,5,7,2,4,5], &#39;Tennis&#39;:[1,2,3,4,5,6,7,8]}) . dataframe . Cricket Baseball Tennis . 0 | 1.0 | 5.0 | 1 | . 1 | 2.0 | NaN | 2 | . 2 | NaN | NaN | 3 | . 3 | 4.0 | 5.0 | 4 | . 4 | 6.0 | 7.0 | 5 | . 5 | 7.0 | 2.0 | 6 | . 6 | 2.0 | 4.0 | 7 | . 7 | NaN | 5.0 | 8 | . dataframe.dropna() . Cricket Baseball Tennis . 0 | 1.0 | 5.0 | 1 | . 3 | 4.0 | 5.0 | 4 | . 4 | 6.0 | 7.0 | 5 | . 5 | 7.0 | 2.0 | 6 | . 6 | 2.0 | 4.0 | 7 | . # Use axis=1 for dropping columns with nan values dataframe.dropna(axis=1) . Tennis . 0 | 1 | . 1 | 2 | . 2 | 3 | . 3 | 4 | . 4 | 5 | . 5 | 6 | . 6 | 7 | . 7 | 8 | . dataframe.dropna(thresh=2) . Cricket Baseball Tennis . 0 | 1.0 | 5.0 | 1 | . 1 | 2.0 | NaN | 2 | . 3 | 4.0 | 5.0 | 4 | . 4 | 6.0 | 7.0 | 5 | . 5 | 7.0 | 2.0 | 6 | . 6 | 2.0 | 4.0 | 7 | . 7 | NaN | 5.0 | 8 | . dataframe.fillna(value=0) . Cricket Baseball Tennis . 0 | 1.0 | 5.0 | 1 | . 1 | 2.0 | 0.0 | 2 | . 2 | 0.0 | 0.0 | 3 | . 3 | 4.0 | 5.0 | 4 | . 4 | 6.0 | 7.0 | 5 | . 5 | 7.0 | 2.0 | 6 | . 6 | 2.0 | 4.0 | 7 | . 7 | 0.0 | 5.0 | 8 | . dataframe[&#39;Baseball&#39;].fillna(value=dataframe[&#39;Baseball&#39;].mean()) . 0 5.000000 1 4.666667 2 4.666667 3 5.000000 4 7.000000 5 2.000000 6 4.000000 7 5.000000 Name: Baseball, dtype: float64 . Groupby . The groupby method is used to group rows together and perform aggregate functions . dat = {&#39;CustID&#39;:[&#39;1001&#39;,&#39;1001&#39;,&#39;1002&#39;,&#39;1002&#39;,&#39;1003&#39;,&#39;1003&#39;], &#39;CustName&#39;:[&#39;UIPat&#39;,&#39;DatRob&#39;,&#39;Goog&#39;,&#39;Chrysler&#39;,&#39;Ford&#39;,&#39;GM&#39;], &#39;Profitinlakhs&#39;:[2005,3245,1245,8765,5463,3547]} . dataframe = pd.DataFrame(dat) . dataframe . CustID CustName Profitinlakhs . 0 | 1001 | UIPat | 2005 | . 1 | 1001 | DatRob | 3245 | . 2 | 1002 | Goog | 1245 | . 3 | 1002 | Chrysler | 8765 | . 4 | 1003 | Ford | 5463 | . 5 | 1003 | GM | 3547 | . We can now use the .groupby() method to group rows together based on a column name. For example let&#39;s group based on CustID. This will create a DataFrameGroupBy object: . dataframe.groupby(&#39;CustID&#39;) #This object can be saved as a variable . &lt;pandas.core.groupby.generic.DataFrameGroupBy object at 0x000001FDFCEFE9C8&gt; . CustID_grouped = dataframe.groupby(&quot;CustID&quot;) #Now we can aggregate using the variable . CustID_grouped.mean() . Profitinlakhs . CustID . 1001 | 2625 | . 1002 | 5005 | . 1003 | 4505 | . groupby function for each aggregation . dataframe.groupby(&#39;CustID&#39;).mean() . Profitinlakhs . CustID . 1001 | 2625 | . 1002 | 5005 | . 1003 | 4505 | . CustID_grouped.std() . Profitinlakhs . CustID . 1001 | 876.812409 | . 1002 | 5317.442995 | . 1003 | 1354.816593 | . CustID_grouped.min() . CustName Profitinlakhs . CustID . 1001 | DatRob | 2005 | . 1002 | Chrysler | 1245 | . 1003 | Ford | 3547 | . CustID_grouped.max() . CustName Profitinlakhs . CustID . 1001 | UIPat | 3245 | . 1002 | Goog | 8765 | . 1003 | GM | 5463 | . CustID_grouped.count() . CustName Profitinlakhs . CustID . 1001 | 2 | 2 | . 1002 | 2 | 2 | . 1003 | 2 | 2 | . CustID_grouped.describe() . Profitinlakhs . count mean std min 25% 50% 75% max . CustID . 1001 | 2.0 | 2625.0 | 876.812409 | 2005.0 | 2315.0 | 2625.0 | 2935.0 | 3245.0 | . 1002 | 2.0 | 5005.0 | 5317.442995 | 1245.0 | 3125.0 | 5005.0 | 6885.0 | 8765.0 | . 1003 | 2.0 | 4505.0 | 1354.816593 | 3547.0 | 4026.0 | 4505.0 | 4984.0 | 5463.0 | . CustID_grouped.describe().transpose() . CustID 1001 1002 1003 . Profitinlakhs | count | 2.000000 | 2.000000 | 2.000000 | . mean | 2625.000000 | 5005.000000 | 4505.000000 | . std | 876.812409 | 5317.442995 | 1354.816593 | . min | 2005.000000 | 1245.000000 | 3547.000000 | . 25% | 2315.000000 | 3125.000000 | 4026.000000 | . 50% | 2625.000000 | 5005.000000 | 4505.000000 | . 75% | 2935.000000 | 6885.000000 | 4984.000000 | . max | 3245.000000 | 8765.000000 | 5463.000000 | . CustID_grouped.describe().transpose()[&#39;1001&#39;] . Profitinlakhs count 2.000000 mean 2625.000000 std 876.812409 min 2005.000000 25% 2315.000000 50% 2625.000000 75% 2935.000000 max 3245.000000 Name: 1001, dtype: float64 . combining DataFrames together: . Merging | Joining | Concatenating | . dafa1 = pd.DataFrame({&#39;CustID&#39;: [&#39;101&#39;, &#39;102&#39;, &#39;103&#39;, &#39;104&#39;], &#39;Sales&#39;: [13456, 45321, 54385, 53212], &#39;Priority&#39;: [&#39;CAT0&#39;, &#39;CAT1&#39;, &#39;CAT2&#39;, &#39;CAT3&#39;], &#39;Prime&#39;: [&#39;yes&#39;, &#39;no&#39;, &#39;no&#39;, &#39;yes&#39;]}, index=[0, 1, 2, 3]) dafa2 = pd.DataFrame({&#39;CustID&#39;: [&#39;101&#39;, &#39;103&#39;, &#39;104&#39;, &#39;105&#39;], &#39;Sales&#39;: [13456, 54385, 53212, 4534], &#39;Payback&#39;: [&#39;CAT4&#39;, &#39;CAT5&#39;, &#39;CAT6&#39;, &#39;CAT7&#39;], &#39;Imp&#39;: [&#39;yes&#39;, &#39;no&#39;, &#39;no&#39;, &#39;no&#39;]}, index=[4, 5, 6, 7]) dafa3 = pd.DataFrame({&#39;CustID&#39;: [&#39;101&#39;, &#39;104&#39;, &#39;105&#39;, &#39;106&#39;], &#39;Sales&#39;: [13456, 53212, 4534, 3241], &#39;Pol&#39;: [&#39;CAT8&#39;, &#39;CAT9&#39;, &#39;CAT10&#39;, &#39;CAT11&#39;], &#39;Level&#39;: [&#39;yes&#39;, &#39;no&#39;, &#39;no&#39;, &#39;yes&#39;]}, index=[8, 9, 10, 11]) . Concatenation . Concatenation joins DataFrames basically either by rows or colums(axis=0 or 1). . We also need to ensure dimension sizes of dataframes are the same . pd.concat([dafa1,dafa2]) . D: Anaconda3 lib site-packages ipykernel_launcher.py:1: FutureWarning: Sorting because non-concatenation axis is not aligned. A future version of pandas will change to not sort by default. To accept the future behavior, pass &#39;sort=False&#39;. To retain the current behavior and silence the warning, pass &#39;sort=True&#39;. &#34;&#34;&#34;Entry point for launching an IPython kernel. . CustID Imp Payback Prime Priority Sales . 0 | 101 | NaN | NaN | yes | CAT0 | 13456 | . 1 | 102 | NaN | NaN | no | CAT1 | 45321 | . 2 | 103 | NaN | NaN | no | CAT2 | 54385 | . 3 | 104 | NaN | NaN | yes | CAT3 | 53212 | . 4 | 101 | yes | CAT4 | NaN | NaN | 13456 | . 5 | 103 | no | CAT5 | NaN | NaN | 54385 | . 6 | 104 | no | CAT6 | NaN | NaN | 53212 | . 7 | 105 | no | CAT7 | NaN | NaN | 4534 | . pd.concat([dafa1,dafa2,dafa3],axis=1) . CustID Sales Priority Prime CustID Sales Payback Imp CustID Sales Pol Level . 0 | 101 | 13456.0 | CAT0 | yes | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | . 1 | 102 | 45321.0 | CAT1 | no | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | . 2 | 103 | 54385.0 | CAT2 | no | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | . 3 | 104 | 53212.0 | CAT3 | yes | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | . 4 | NaN | NaN | NaN | NaN | 101 | 13456.0 | CAT4 | yes | NaN | NaN | NaN | NaN | . 5 | NaN | NaN | NaN | NaN | 103 | 54385.0 | CAT5 | no | NaN | NaN | NaN | NaN | . 6 | NaN | NaN | NaN | NaN | 104 | 53212.0 | CAT6 | no | NaN | NaN | NaN | NaN | . 7 | NaN | NaN | NaN | NaN | 105 | 4534.0 | CAT7 | no | NaN | NaN | NaN | NaN | . 8 | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | 101 | 13456.0 | CAT8 | yes | . 9 | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | 104 | 53212.0 | CAT9 | no | . 10 | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | 105 | 4534.0 | CAT10 | no | . 11 | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | 106 | 3241.0 | CAT11 | yes | . Merging . Just like SQL tables, merge function in python allows us to merge dataframes . pd.merge(dafa1,dafa2,how=&#39;outer&#39;,on=&#39;CustID&#39;) . CustID Sales_x Priority Prime Sales_y Payback Imp . 0 | 101 | 13456.0 | CAT0 | yes | 13456.0 | CAT4 | yes | . 1 | 102 | 45321.0 | CAT1 | no | NaN | NaN | NaN | . 2 | 103 | 54385.0 | CAT2 | no | 54385.0 | CAT5 | no | . 3 | 104 | 53212.0 | CAT3 | yes | 53212.0 | CAT6 | no | . 4 | 105 | NaN | NaN | NaN | 4534.0 | CAT7 | no | . Operations . Let us discuss some useful Operations using Pandas . dataframe = pd.DataFrame({&#39;custID&#39;:[1,2,3,4],&#39;SaleType&#39;:[&#39;big&#39;,&#39;small&#39;,&#39;medium&#39;,&#39;big&#39;],&#39;SalesCode&#39;:[&#39;121&#39;,&#39;131&#39;,&#39;141&#39;,&#39;151&#39;]}) dataframe.head() . custID SaleType SalesCode . 0 | 1 | big | 121 | . 1 | 2 | small | 131 | . 2 | 3 | medium | 141 | . 3 | 4 | big | 151 | . Info on Unique Values . dataframe[&#39;SaleType&#39;].unique() . array([&#39;big&#39;, &#39;small&#39;, &#39;medium&#39;], dtype=object) . dataframe[&#39;SaleType&#39;].nunique() . 3 . dataframe[&#39;SaleType&#39;].value_counts() . big 2 small 1 medium 1 Name: SaleType, dtype: int64 . Selecting Data . #Select from DataFrame using criteria from multiple columns newdataframe = dataframe[(dataframe[&#39;custID&#39;]!=3) &amp; (dataframe[&#39;SaleType&#39;]==&#39;big&#39;)] newdataframe . custID SaleType SalesCode . 0 | 1 | big | 121 | . 3 | 4 | big | 151 | . Applying Functions . def profit(a): return a*4 . dataframe[&#39;custID&#39;].apply(profit) . 0 4 1 8 2 12 3 16 Name: custID, dtype: int64 . dataframe[&#39;SaleType&#39;].apply(len) . 0 3 1 5 2 6 3 3 Name: SaleType, dtype: int64 . dataframe[&#39;custID&#39;].sum() . 10 . Permanently Removing a Column . dataframe . custID SaleType SalesCode . 0 | 1 | big | 121 | . 1 | 2 | small | 131 | . 2 | 3 | medium | 141 | . 3 | 4 | big | 151 | . del dataframe[&#39;custID&#39;] dataframe . SaleType SalesCode . 0 | big | 121 | . 1 | small | 131 | . 2 | medium | 141 | . 3 | big | 151 | . Get column and index names . dataframe.columns . Index([&#39;SaleType&#39;, &#39;SalesCode&#39;], dtype=&#39;object&#39;) . dataframe.index . RangeIndex(start=0, stop=4, step=1) . Sorting and Ordering a DataFrame . dataframe.sort_values(by=&#39;SaleType&#39;) #inplace=False by default . SaleType SalesCode . 0 | big | 121 | . 3 | big | 151 | . 2 | medium | 141 | . 1 | small | 131 | . Find Null Values or Check for Null Values . dataframe.isnull() . SaleType SalesCode . 0 | False | False | . 1 | False | False | . 2 | False | False | . 3 | False | False | . # Drop rows with NaN Values dataframe.dropna() . SaleType SalesCode . 0 | big | 121 | . 1 | small | 131 | . 2 | medium | 141 | . 3 | big | 151 | . Filling in NaN values with something else . dataframe = pd.DataFrame({&#39;Sale1&#39;:[5,np.nan,10,np.nan], &#39;Sale2&#39;:[np.nan,121,np.nan,141], &#39;Sale3&#39;:[&#39;XUI&#39;,&#39;VYU&#39;,&#39;NMA&#39;,&#39;IUY&#39;]}) dataframe.head() . Sale1 Sale2 Sale3 . 0 | 5.0 | NaN | XUI | . 1 | NaN | 121.0 | VYU | . 2 | 10.0 | NaN | NMA | . 3 | NaN | 141.0 | IUY | . dataframe.fillna(&#39;Not nan&#39;) . Sale1 Sale2 Sale3 . 0 | 5 | Not nan | XUI | . 1 | Not nan | 121 | VYU | . 2 | 10 | Not nan | NMA | . 3 | Not nan | 141 | IUY | . Data Input and Output . Reading DataFrames from external sources using pd.read functions . CSV Input . # dataframe = pd.read_csv(&#39;filename.csv&#39;) . CSV output . #If index=FALSE then csv does not store index values # dataframe.to_csv(&#39;filename.csv&#39;,index=False) . Excel Input . # pd.read_excel(&#39;filename.xlsx&#39;,sheet_name=&#39;Data1&#39;) . Excel Output . # dataframe.to_excel(&#39;Consumer2.xlsx&#39;,sheet_name=&#39;Sheet1&#39;) .",
            "url": "https://itskarthicklakshmanan.github.io/kalanai/2020/01/28/python_for_ML.html",
            "relUrl": "/2020/01/28/python_for_ML.html",
            "date": " • Jan 28, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "This is where you put the contents of your About page. Like all your pages, it’s in Markdown format. . This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://itskarthicklakshmanan.github.io/kalanai/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  
      ,"page2": {
          "title": "Datasets",
          "content": "",
          "url": "https://itskarthicklakshmanan.github.io/kalanai/datasets/",
          "relUrl": "/datasets/",
          "date": ""
      }
      
  

  

  
      ,"page4": {
          "title": "Useful Links",
          "content": "Collection . Awesome Open Source–Combining 7,000 Topics Across 59 Categories And 320,386 Projects [Webpage] . Curated list of libraries for a faster machine learning workflow [GitHub Listical] . Python . The Entire Python Language in a Single Image [Link] [GitHub] | .",
          "url": "https://itskarthicklakshmanan.github.io/kalanai/links/",
          "relUrl": "/links/",
          "date": ""
      }
      
  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page12": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://itskarthicklakshmanan.github.io/kalanai/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}